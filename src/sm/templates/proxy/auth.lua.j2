-- /etc/openresty/lua/auth.lua
-- API Key authentication with rate limiting
-- Generated by sm proxy - DO NOT EDIT MANUALLY

local cjson = require "cjson.safe"

-- Get API key from request headers
local function get_api_key()
    -- Check Authorization: Bearer <key>
    local auth_header = ngx.var.http_authorization
    if auth_header then
        local key = string.match(auth_header, "Bearer%s+(.+)")
        if key then
            return key
        end
    end

    -- Check X-API-Key header
    local api_key = ngx.var.http_x_api_key
    if api_key and api_key ~= "" then
        return api_key
    end

    return nil
end

-- Validate key against stored keys
local function validate_key(key)
    local keys_dict = ngx.shared.api_keys
    local key_data_json = keys_dict:get(key)

    if not key_data_json then
        return nil, "invalid_key"
    end

    local key_data, err = cjson.decode(key_data_json)
    if not key_data then
        ngx.log(ngx.ERR, "Failed to decode key data: ", err)
        return nil, "internal_error"
    end

    -- Check if enabled
    if not key_data.enabled then
        return nil, "key_disabled"
    end

    -- Check expiry (note: JSON null becomes cjson.null userdata, not nil)
    if key_data.expires_at and type(key_data.expires_at) == "string" then
        -- Parse ISO 8601 timestamp
        local year, month, day, hour, min, sec = string.match(
            key_data.expires_at,
            "(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+)"
        )
        if year then
            local expires = os.time({
                year = tonumber(year),
                month = tonumber(month),
                day = tonumber(day),
                hour = tonumber(hour),
                min = tonumber(min),
                sec = tonumber(sec)
            })
            if ngx.time() > expires then
                return nil, "key_expired"
            end
        end
    end

    -- Check endpoint access
    local server_port = tostring(ngx.var.server_port)
    local has_access = false

    if key_data.endpoints then
        for _, ep in ipairs(key_data.endpoints) do
            if ep == "*" or ep == server_port then
                has_access = true
                break
            end
            -- Also check by endpoint name (stored in endpoints list)
            -- Port matching is primary, name matching as fallback
        end
    else
        -- No endpoint restrictions = access to all
        has_access = true
    end

    if not has_access then
        return nil, "endpoint_not_allowed"
    end

    return key_data, nil
end

-- Rate limiting using sliding window
local function check_rate_limit(key_name, limit)
    -- Note: JSON null becomes cjson.null userdata, not nil
    if not limit or type(limit) ~= "number" or limit <= 0 then
        return true
    end

    local rate_limit_dict = ngx.shared.rate_limit
    local key = "rl:" .. key_name
    local window = 60  -- 60 second window

    -- Increment counter with TTL
    local count, err = rate_limit_dict:incr(key, 1, 0, window)
    if not count then
        ngx.log(ngx.ERR, "Rate limit error: ", err)
        return true  -- Fail open on error
    end

    if count > limit then
        return false
    end

    return true
end

-- Log authentication attempt
local function log_auth(status, key_name, reason)
    local log_data = {
        time = ngx.var.time_iso8601,
        remote_addr = ngx.var.remote_addr,
        method = ngx.var.request_method,
        uri = ngx.var.uri,
        status = status,
        key_name = key_name or "-",
        reason = reason or "-",
        user_agent = ngx.var.http_user_agent or "-"
    }

    -- Log to error log at info level for audit
    if status == "denied" then
        ngx.log(ngx.WARN, "AUTH_DENIED: ", cjson.encode(log_data))
    end
end

-- ============================================================================
-- Main authentication logic
-- ============================================================================

local key = get_api_key()

if not key then
    log_auth("denied", nil, "missing_api_key")

    ngx.status = 401
    ngx.header["WWW-Authenticate"] = 'Bearer realm="API", error="missing_token"'
    ngx.header["Content-Type"] = "application/json"
    ngx.say('{"error":"missing_api_key","message":"API key required. Use Authorization: Bearer <key> or X-API-Key header."}')
    return ngx.exit(401)
end

local key_data, err = validate_key(key)

if not key_data then
    log_auth("denied", nil, err)

    local status_code = 401
    local error_messages = {
        invalid_key = "Invalid API key",
        key_disabled = "API key has been revoked",
        key_expired = "API key has expired",
        endpoint_not_allowed = "API key not authorized for this endpoint",
        internal_error = "Internal authentication error"
    }

    local message = error_messages[err] or "Authentication failed"

    ngx.status = status_code
    ngx.header["Content-Type"] = "application/json"
    ngx.say(cjson.encode({error = err, message = message}))
    return ngx.exit(status_code)
end

-- Check rate limit
if not check_rate_limit(key_data.name, key_data.rate_limit) then
    log_auth("denied", key_data.name, "rate_limit_exceeded")

    ngx.status = 429
    ngx.header["Content-Type"] = "application/json"
    ngx.header["Retry-After"] = "60"
    ngx.say(cjson.encode({
        error = "rate_limit_exceeded",
        message = "Too many requests. Limit: " .. tostring(key_data.rate_limit) .. " per minute."
    }))
    return ngx.exit(429)
end

-- Authentication successful - set key name for logging
ngx.var.api_key_name = key_data.name
